#include <linux/errno.h>
#include <linux/kernel.h>
#include <linux/miscdevice.h>
#include <linux/fcntl.h>
#include <linux/init.h>
#include <linux/delay.h>
#include <linux/fs.h>

#include <asm/uaccess.h>
#include <asm/sections.h>
#include <asm/io.h>
#include <asm/mach-cheetah/cheetah.h>
#include <asm/mach-cheetah/gpio.h>

#if defined(CONFIG_CHEETAH_LCD_BACKLIGHT_PWM_A) || defined(CONFIG_CHEETAH_LCD_BACKLIGHT_PWM_B)
#include "cta_pwm.h"

extern struct pwm_dev *pwm;
#endif

#define CMD_DISPLAY_OFF 0xAE
#define CMD_DISPLAY_ON 0xAF

#define CMD_SET_DISP_START_LINE 0x40
#define CMD_SET_PAGE 0xB0

#define CMD_SET_COLUMN_UPPER 0x10
#define CMD_SET_COLUMN_LOWER 0x00

#define CMD_SET_ADC_NORMAL 0xA0
#define CMD_SET_ADC_REVERSE 0xA1

#define CMD_SET_DISP_NORMAL 0xA6
#define CMD_SET_DISP_REVERSE 0xA7

#define CMD_SET_ALLPTS_NORMAL 0xA4
#define CMD_SET_ALLPTS_ON 0xA5
#define CMD_SET_BIAS_9 0xA2
#define CMD_SET_BIAS_7 0xA3

#define CMD_RMW 0xE0
#define CMD_RMW_CLEAR 0xEE
#define CMD_INTERNAL_RESET 0xE2
#define CMD_SET_COM_NORMAL 0xC0
#define CMD_SET_COM_REVERSE 0xC8
#define CMD_SET_POWER_CONTROL 0x28
#define CMD_SET_RESISTOR_RATIO 0x20
#define CMD_SET_VOLUME_FIRST 0x81
#define CMD_SET_VOLUME_SECOND 0
#define CMD_SET_STATIC_OFF 0xAC
#define CMD_SET_STATIC_ON 0xAD
#define CMD_SET_STATIC_REG 0x0
#define CMD_SET_BOOSTER_FIRST 0xF8
#define CMD_SET_BOOSTER_234 0
#define CMD_SET_BOOSTER_5 1
#define CMD_SET_BOOSTER_6 3
#define CMD_NOP 0xE3
#define CMD_TEST 0xF0

#define FONT_COL_SIZE 6

const unsigned char Font8x5[][FONT_COL_SIZE] = {
{0x00,0x00,0x00,0x00,0x00,0x00},   //   0x 0 0
{0x00,0x64,0x18,0x04,0x64,0x18},   //  0x 1 1
{0x00,0x3c,0x40,0x40,0x20,0x7c},   //  0x 2 2
{0x00,0x0c,0x30,0x40,0x30,0x0c},   //  0x 3 3
{0x00,0x3c,0x40,0x30,0x40,0x3c},   //  0x 4 4
{0x00,0x00,0x3e,0x1c,0x08,0x00},   //  0x 5 5
{0x00,0x04,0x1e,0x1f,0x1e,0x04},   //  0x 6 6
{0x00,0x10,0x3c,0x7c,0x3c,0x10},   //  0x 7 7
{0x00,0x20,0x40,0x3e,0x01,0x02},   //  0x 8 8
{0x00,0x22,0x14,0x08,0x14,0x22},   //   0x 9 9
{0x00,0x00,0x38,0x28,0x38,0x00},   //   0x a 10
{0x00,0x00,0x10,0x38,0x10,0x00},   //  0x b 11
{0x00,0x00,0x00,0x10,0x00,0x00},   //  0x c 12
{0x00,0x08,0x78,0x08,0x00,0x00},   //   0x d 13
{0x00,0x00,0x15,0x15,0x0a,0x00},   //  0x e 14
{0x00,0x7f,0x7f,0x09,0x09,0x01},   //  0x f 15
{0x00,0x10,0x20,0x7f,0x01,0x01},   //  0x10 16
{0x00,0x04,0x04,0x00,0x01,0x1f},   //  0x11 17
{0x00,0x00,0x19,0x15,0x12,0x00},   //  0x12 18
{0x00,0x40,0x60,0x50,0x48,0x44},   //  0x13 19
{0x00,0x06,0x09,0x09,0x06,0x00},   //  0x14 20
{0x00,0x0f,0x02,0x01,0x01,0x00},   //  0x15 21
{0x00,0x00,0x01,0x1f,0x01,0x00},   //  0x16 22
{0x00,0x44,0x44,0x4a,0x4a,0x51},   //  0x17 23
{0x00,0x14,0x74,0x1c,0x17,0x14},   //  0x18 24
{0x00,0x51,0x4a,0x4a,0x44,0x44},   //  0x19 25
{0x00,0x00,0x00,0x04,0x04,0x04},   //   0x1a 26
{0x00,0x00,0x7c,0x54,0x54,0x44},   //  0x1b 27
{0x00,0x08,0x08,0x2a,0x1c,0x08},   //   0x1c 28
{0x00,0x7c,0x00,0x7c,0x44,0x7c},   //   0x1d 29
{0x00,0x04,0x02,0x7f,0x02,0x04},   //   0x1e 30
{0x00,0x10,0x20,0x7f,0x20,0x10},   //   0x1f 31
{0x00,0x00,0x00,0x00,0x00,0x00},   //   0x20 32
{0x00,0x00,0x00,0x6f,0x00,0x00},   // ! 0x21 33
{0x00,0x00,0x07,0x00,0x07,0x00},   // " 0x22 34
{0x00,0x14,0x7f,0x14,0x7f,0x14},   // # 0x23 35
{0x00,0x00,0x07,0x04,0x1e,0x00},   // $ 0x24 36
{0x00,0x23,0x13,0x08,0x64,0x62},   // % 0x25 37
{0x00,0x36,0x49,0x56,0x20,0x50},   // & 0x26 38
{0x00,0x00,0x00,0x07,0x00,0x00},   // ' 0x27 39
{0x00,0x00,0x1c,0x22,0x41,0x00},   // ( 0x28 40
{0x00,0x00,0x41,0x22,0x1c,0x00},   // ) 0x29 41
{0x00,0x14,0x08,0x3e,0x08,0x14},   // * 0x2a 42
{0x00,0x08,0x08,0x3e,0x08,0x08},   // + 0x2b 43
{0x00,0x00,0x50,0x30,0x00,0x00},   // , 0x2c 44
{0x00,0x08,0x08,0x08,0x08,0x08},   // - 0x2d 45
{0x00,0x00,0x60,0x60,0x00,0x00},   // . 0x2e 46
{0x00,0x20,0x10,0x08,0x04,0x02},   // / 0x2f 47
{0x00,0x3e,0x51,0x49,0x45,0x3e},   // 0 0x30 48
{0x00,0x00,0x42,0x7f,0x40,0x00},   // 1 0x31 49
{0x00,0x42,0x61,0x51,0x49,0x46},   // 2 0x32 50
{0x00,0x21,0x41,0x45,0x4b,0x31},   // 3 0x33 51
{0x00,0x18,0x14,0x12,0x7f,0x10},   // 4 0x34 52
{0x00,0x27,0x45,0x45,0x45,0x39},   // 5 0x35 53
{0x00,0x3c,0x4a,0x49,0x49,0x30},   // 6 0x36 54
{0x00,0x01,0x71,0x09,0x05,0x03},   // 7 0x37 55
{0x00,0x36,0x49,0x49,0x49,0x36},   // 8 0x38 56
{0x00,0x06,0x49,0x49,0x29,0x1e},   // 9 0x39 57
{0x00,0x00,0x36,0x36,0x00,0x00},   // : 0x3a 58
{0x00,0x00,0x56,0x36,0x00,0x00},   // ; 0x3b 59
{0x00,0x08,0x14,0x22,0x41,0x00},   // < 0x3c 60
{0x00,0x14,0x14,0x14,0x14,0x14},   // = 0x3d 61
{0x00,0x00,0x41,0x22,0x14,0x08},   // > 0x3e 62
{0x00,0x02,0x01,0x51,0x09,0x06},   // ? 0x3f 63
{0x00,0x3e,0x41,0x5d,0x49,0x4e},   // @ 0x40 64
{0x00,0x7e,0x09,0x09,0x09,0x7e},   // A 0x41 65
{0x00,0x7f,0x49,0x49,0x49,0x36},   // B 0x42 66
{0x00,0x3e,0x41,0x41,0x41,0x22},   // C 0x43 67
{0x00,0x7f,0x41,0x41,0x41,0x3e},   // D 0x44 68
{0x00,0x7f,0x49,0x49,0x49,0x41},   // E 0x45 69
{0x00,0x7f,0x09,0x09,0x09,0x01},   // F 0x46 70
{0x00,0x3e,0x41,0x49,0x49,0x7a},   // G 0x47 71
{0x00,0x7f,0x08,0x08,0x08,0x7f},   // H 0x48 72
{0x00,0x00,0x41,0x7f,0x41,0x00},   // I 0x49 73
{0x00,0x20,0x40,0x41,0x3f,0x01},   // J 0x4a 74
{0x00,0x7f,0x08,0x14,0x22,0x41},   // K 0x4b 75
{0x00,0x7f,0x40,0x40,0x40,0x40},   // L 0x4c 76
{0x00,0x7f,0x02,0x0c,0x02,0x7f},   // M 0x4d 77
{0x00,0x7f,0x04,0x08,0x10,0x7f},   // N 0x4e 78
{0x00,0x3e,0x41,0x41,0x41,0x3e},   // O 0x4f 79
{0x00,0x7f,0x09,0x09,0x09,0x06},   // P 0x50 80
{0x00,0x3e,0x41,0x51,0x21,0x5e},   // Q 0x51 81
{0x00,0x7f,0x09,0x19,0x29,0x46},   // R 0x52 82
{0x00,0x46,0x49,0x49,0x49,0x31},   // S 0x53 83
{0x00,0x01,0x01,0x7f,0x01,0x01},   // T 0x54 84
{0x00,0x3f,0x40,0x40,0x40,0x3f},   // U 0x55 85
{0x00,0x0f,0x30,0x40,0x30,0x0f},   // V 0x56 86
{0x00,0x3f,0x40,0x30,0x40,0x3f},   // W 0x57 87
{0x00,0x63,0x14,0x08,0x14,0x63},   // X 0x58 88
{0x00,0x07,0x08,0x70,0x08,0x07},   // Y 0x59 89
{0x00,0x61,0x51,0x49,0x45,0x43},   // Z 0x5a 90
{0x00,0x3c,0x4a,0x49,0x29,0x1e},   // [ 0x5b 91
{0x00,0x02,0x04,0x08,0x10,0x20},   // \ 0x5c 92
{0x00,0x00,0x41,0x7f,0x00,0x00},   // ] 0x5d 93
{0x00,0x04,0x02,0x01,0x02,0x04},   // ^ 0x5e 94
{0x00,0x40,0x40,0x40,0x40,0x40},   // _ 0x5f 95
{0x00,0x00,0x00,0x03,0x04,0x00},   // ` 0x60 96
{0x00,0x20,0x54,0x54,0x54,0x78},   // a 0x61 97
{0x00,0x7f,0x48,0x44,0x44,0x38},   // b 0x62 98
{0x00,0x38,0x44,0x44,0x44,0x20},   // c 0x63 99
{0x00,0x38,0x44,0x44,0x48,0x7f},   // d 0x64 100
{0x00,0x38,0x54,0x54,0x54,0x18},   // e 0x65 101
{0x00,0x08,0x7e,0x09,0x01,0x02},   // f 0x66 102
{0x00,0x0c,0x52,0x52,0x52,0x3e},   // g 0x67 103
{0x00,0x7f,0x08,0x04,0x04,0x78},   // h 0x68 104
{0x00,0x00,0x44,0x7d,0x40,0x00},   // i 0x69 105
{0x00,0x20,0x40,0x44,0x3d,0x00},   // j 0x6a 106
{0x00,0x00,0x7f,0x10,0x28,0x44},   // k 0x6b 107
{0x00,0x00,0x41,0x7f,0x40,0x00},   // l 0x6c 108
{0x00,0x7c,0x04,0x18,0x04,0x78},   // m 0x6d 109
{0x00,0x7c,0x08,0x04,0x04,0x78},   // n 0x6e 110
{0x00,0x38,0x44,0x44,0x44,0x38},   // o 0x6f 111
{0x00,0x7c,0x14,0x14,0x14,0x08},   // p 0x70 112
{0x00,0x08,0x14,0x14,0x18,0x7c},   // q 0x71 113
{0x00,0x7c,0x08,0x04,0x04,0x08},   // r 0x72 114
{0x00,0x48,0x54,0x54,0x54,0x20},   // s 0x73 115
{0x00,0x04,0x3f,0x44,0x40,0x20},   // t 0x74 116
{0x00,0x3c,0x40,0x40,0x20,0x7c},   // u 0x75 117
{0x00,0x1c,0x20,0x40,0x20,0x1c},   // v 0x76 118
{0x00,0x3c,0x40,0x30,0x40,0x3c},   // w 0x77 119
{0x00,0x44,0x28,0x10,0x28,0x44},   // x 0x78 120
{0x00,0x0c,0x50,0x50,0x50,0x3c},   // y 0x79 121
{0x00,0x44,0x64,0x54,0x4c,0x44},   // z 0x7a 122
{0x00,0x00,0x08,0x36,0x41,0x41},   // { 0x7b 123
{0x00,0x00,0x00,0x7f,0x00,0x00},   // | 0x7c 124
{0x00,0x41,0x41,0x36,0x08,0x00},   // } 0x7d 125
{0x00,0x04,0x02,0x04,0x08,0x04},   // ~ 0x7e 126
{0x00,0x7f,0x6b,0x6b,0x6b,0x7f},   //  0x7f 127
{0x00,0x00,0x7c,0x44,0x7c,0x00},   // ¬¨ 0x80 128
{0x00,0x00,0x08,0x7c,0x00,0x00},   // ¬Å 0x81 129
{0x00,0x00,0x64,0x54,0x48,0x00},   // ‚Äö 0x82 130
{0x00,0x00,0x44,0x54,0x28,0x00},   // ∆í 0x83 131
{0x00,0x00,0x1c,0x10,0x78,0x00},   // ‚Äû 0x84 132
{0x00,0x00,0x5c,0x54,0x24,0x00},   // ‚Ä¶ 0x85 133
{0x00,0x00,0x78,0x54,0x74,0x00},   // ‚Ä† 0x86 134
{0x00,0x00,0x64,0x14,0x0c,0x00},   // ‚Ä° 0x87 135
{0x00,0x00,0x7c,0x54,0x7c,0x00},   // ÀÜ 0x88 136
{0x00,0x00,0x5c,0x54,0x3c,0x00},   // ‚Ä∞ 0x89 137
{0x00,0x78,0x24,0x26,0x25,0x78},   // ≈† 0x8a 138
{0x00,0x78,0x25,0x26,0x24,0x78},   // ‚Äπ 0x8b 139
{0x00,0x70,0x2a,0x29,0x2a,0x70},   // ≈í 0x8c 140
{0x00,0x78,0x25,0x24,0x25,0x78},   // ¬ç 0x8d 141
{0x00,0x20,0x54,0x56,0x55,0x78},   // } 0x8e 142
{0x00,0x20,0x55,0x56,0x54,0x78},   // ¬è 0x8f 143
{0x00,0x20,0x56,0x55,0x56,0x78},   // ¬ê 0x90 144
{0x00,0x20,0x55,0x54,0x55,0x78},   // ‚Äò 0x91 145
{0x00,0x7c,0x54,0x56,0x55,0x44},   // ‚Äô 0x92 146
{0x00,0x7c,0x55,0x56,0x54,0x44},   // ‚Äú 0x93 147
{0x00,0x7c,0x56,0x55,0x56,0x44},   // ‚Äù 0x94 148
{0x00,0x7c,0x55,0x54,0x55,0x44},   // ‚Ä¢ 0x95 149
{0x00,0x38,0x54,0x56,0x55,0x18},   // ‚Äì 0x96 150
{0x00,0x38,0x55,0x56,0x54,0x18},   // ‚Äî 0x97 151
{0x00,0x38,0x56,0x55,0x56,0x18},   // Àú 0x98 152
{0x00,0x38,0x55,0x54,0x55,0x18},   // ‚Ñ¢ 0x99 153
{0x00,0x00,0x44,0x7e,0x45,0x00},   // ≈° 0x9a 154
{0x00,0x00,0x45,0x7e,0x44,0x00},   // ‚Ä∫ 0x9b 155
{0x00,0x00,0x46,0x7d,0x46,0x00},   // ≈ì 0x9c 156
{0x00,0x00,0x45,0x7c,0x45,0x00},   // ¬ù 0x9d 157
{0x00,0x00,0x48,0x7a,0x41,0x00},   // ~ 0x9e 158
{0x00,0x00,0x49,0x7a,0x40,0x00},   // ≈∏ 0x9f 159
{0x00,0x00,0x4a,0x79,0x42,0x00},   //   0xa0 160
{0x00,0x00,0x49,0x78,0x41,0x00},   // ¬° 0xa1 161
{0x00,0x38,0x44,0x46,0x45,0x38},   // ¬¢ 0xa2 162
{0x00,0x38,0x45,0x46,0x44,0x38},   // ¬£ 0xa3 163
{0x00,0x38,0x46,0x45,0x46,0x38},   // ¬§ 0xa4 164
{0x00,0x38,0x45,0x44,0x45,0x38},   // ¬• 0xa5 165
{0x00,0x30,0x48,0x4a,0x49,0x30},   // ¬¶ 0xa6 166
{0x00,0x30,0x49,0x4a,0x48,0x30},   // ¬ß 0xa7 167
{0x00,0x30,0x4a,0x49,0x4a,0x30},   // ¬® 0xa8 168
{0x00,0x30,0x49,0x48,0x49,0x30},   // ¬© 0xa9 169
{0x00,0x3c,0x40,0x42,0x41,0x3c},   // ¬™ 0xaa 170
{0x00,0x3c,0x41,0x42,0x40,0x3c},   // ¬´ 0xab 171
{0x00,0x3c,0x42,0x41,0x42,0x3c},   // ¬¨ 0xac 172
{0x00,0x3c,0x41,0x40,0x41,0x3c},   // ¬≠ 0xad 173
{0x00,0x3c,0x40,0x42,0x21,0x7c},   // ¬Æ 0xae 174
{0x00,0x3c,0x41,0x42,0x20,0x7c},   // ¬Ø 0xaf 175
{0x00,0x38,0x42,0x41,0x22,0x78},   // ¬∞ 0xb0 176
{0x00,0x3c,0x41,0x40,0x21,0x7c},   // ¬± 0xb1 177
{0x00,0x4e,0x51,0x71,0x11,0x0a},   // ¬≤ 0xb2 178
{0x00,0x58,0x64,0x64,0x24,0x10},   // ¬≥ 0xb3 179
{0x00,0x7c,0x0a,0x11,0x22,0x7d},   // ¬¥ 0xb4 180
{0x00,0x78,0x12,0x09,0x0a,0x71},   // ¬µ 0xb5 181
{0x00,0x00,0x00,0x04,0x02,0x01},   // ¬∂ 0xb6 182
{0x00,0x01,0x02,0x04,0x00,0x00},   // ¬∑ 0xb7 183
{0x00,0x00,0x02,0x00,0x02,0x00},   // ¬∏ 0xb8 184
{0x00,0x30,0x48,0x45,0x40,0x20},   // ¬π 0xb9 185
{0x00,0x00,0x00,0x7b,0x00,0x00},   // ¬∫ 0xba 186
{0x00,0x38,0x44,0x44,0x38,0x44},   // ¬ª 0xbb 187
{0x00,0x40,0x3e,0x49,0x49,0x36},   // ¬º 0xbc 188
{0x00,0x08,0x04,0x08,0x70,0x0c},   // ¬Ω 0xbd 189
{0x00,0x60,0x50,0x48,0x50,0x60},   // ¬æ 0xbe 190
{0x00,0x20,0x52,0x55,0x59,0x30},   // ¬ø 0xbf 191
{0x00,0x38,0x54,0x54,0x54,0x00},   // √Ä 0xc0 192
{0x00,0x00,0x00,0x7f,0x41,0x00},   // √Å 0xc1 193
{0x00,0x40,0x22,0x14,0x18,0x60},   // √Ç 0xc2 194
{0x00,0x7c,0x20,0x20,0x1c,0x20},   // √É 0xc3 195
{0x00,0x44,0x3c,0x04,0x7c,0x44},   // √Ñ 0xc4 196
{0x00,0x40,0x3c,0x12,0x12,0x0c},   // √Ö 0xc5 197
{0x00,0x41,0x63,0x55,0x49,0x41},   // √Ü 0xc6 198
{0x00,0x38,0x44,0x44,0x3c,0x04},   // √á 0xc7 199
{0x00,0x08,0x04,0x3c,0x44,0x24},   // √à 0xc8 200
{0x00,0x08,0x14,0x7f,0x14,0x08},   // √â 0xc9 201
{0x00,0x4e,0x71,0x01,0x71,0x4e},   // √ä 0xca 202
{0x00,0x45,0x29,0x11,0x29,0x45},   // √ã 0xcb 203
{0x00,0x0d,0x51,0x51,0x51,0x3d},   // √å 0xcc 204
{0x00,0x00,0x00,0x05,0x02,0x05},   // √ç 0xcd 205
{0x00,0x40,0x00,0x40,0x00,0x40},   // √é 0xce 206
{0x00,0x00,0x08,0x1c,0x3e,0x00},   // √è 0xcf 207
{0x00,0x1c,0x1c,0x1c,0x00,0x00},   // √ê 0xd0 208
{0x00,0x00,0x70,0x08,0x07,0x00},   // √ë 0xd1 209
{0x00,0x00,0x08,0x08,0x08,0x00},   // √í 0xd2 210
{0x00,0x00,0x1d,0x15,0x17,0x00},   // √ì 0xd3 211
{0x00,0x00,0x07,0x05,0x07,0x00},   // √î 0xd4 212
{0x00,0x00,0x11,0x15,0x0a,0x00},   // √ï 0xd5 213
{0x00,0x00,0x00,0x00,0x00,0x00},   // √ñ 0xd6 214
{0x00,0x04,0x3c,0x41,0x20,0x00},   // √ó 0xd7 215
{0x00,0x7c,0x16,0x15,0x16,0x08},   // √ò 0xd8 216
{0x00,0x21,0x16,0x08,0x34,0x42},   // √ô 0xd9 217
{0x00,0x7f,0x09,0x1d,0x01,0x03},   // √ö 0xda 218
{0x00,0x38,0x54,0x54,0x14,0x08},   // √õ 0xdb 219
{0x00,0x00,0x00,0x7c,0x40,0x40},   // √ú 0xdc 220
{0x00,0x7f,0x0e,0x1c,0x38,0x7f},   // √ù 0xdd 221
{0x00,0x41,0x22,0x5d,0x22,0x1c},   // √û 0xde 222
{0x00,0x1c,0x3e,0x1c,0x08,0x00},   // √ü 0xdf 223
{0x00,0x7f,0x7f,0x7f,0x7f,0x7f},   // √† 0xe0 224
{0x00,0x77,0x7b,0x01,0x7b,0x77},   // √° 0xe1 225
{0x00,0x7f,0x43,0x75,0x43,0x7f},   // √¢ 0xe2 226
{0x00,0x7f,0x6f,0x55,0x43,0x7f},   // √£ 0xe3 227
{0x00,0x40,0x40,0x40,0x40,0x40},   // √§ 0xe4 228
{0x00,0x44,0x42,0x5f,0x42,0x44},   // √• 0xe5 229
{0x00,0x40,0x5e,0x45,0x5e,0x40},   // √¶ 0xe6 230
{0x00,0x40,0x48,0x55,0x5e,0x40},   // √ß 0xe7 231
{0x00,0x00,0x04,0x08,0x10,0x20},   // √® 0xe8 232
{0x00,0x03,0x07,0x0e,0x1c,0x38},   // √© 0xe9 233
{0x00,0x01,0x03,0x07,0x0f,0x1f},   // √™ 0xea 234
{0x00,0x7c,0x78,0x70,0x60,0x40},   // √´ 0xeb 235
{0x00,0x08,0x08,0x1c,0x22,0x1c},   // √¨ 0xec 236
{0x00,0x00,0x1c,0x22,0x1c,0x00},   // √≠ 0xed 237
{0x00,0x02,0x00,0x08,0x00,0x20},   // √Æ 0xee 238
{0x00,0x04,0x3e,0x3f,0x3e,0x04},   // √Ø 0xef 239
{0x00,0x10,0x3e,0x7e,0x3e,0x10},   // √∞ 0xf0 240
{0x00,0x55,0x2a,0x55,0x2a,0x55},   // √± 0xf1 241
{0x00,0x24,0x2a,0x7f,0x2a,0x12},   // √≤ 0xf2 242
{0x00,0x04,0x1e,0x1f,0x1e,0x04},   // √≥ 0xf3 243
{0x00,0x00,0x00,0x00,0x00,0x00},   // √¥ 0xf4 244
{0x00,0x00,0x00,0x00,0x00,0x00},   // √µ 0xf5 245
{0x00,0x00,0x00,0x00,0x00,0x00},   // √∂ 0xf6 246
{0x00,0x00,0x00,0x00,0x00,0x00},   // √∑ 0xf7 247
{0x00,0x00,0x00,0x00,0x00,0x00},   // √∏ 0xf8 248
{0x00,0x00,0x00,0x00,0x00,0x00},   // √π 0xf9 249
{0x00,0x00,0x00,0x00,0x00,0x00},   // √∫ 0xfa 250
{0x00,0x00,0x00,0x00,0x00,0x00},   // √ª 0xfb 251
{0x00,0x00,0x00,0x00,0x00,0x00},   // √º 0xfc 252
{0x00,0x00,0x00,0x00,0x00,0x00},   // √Ω 0xfd 253
{0x00,0x00,0x00,0x00,0x00,0x00},   // √æ 0xfe 254
{0x00,0x00,0x00,0x00,0x00,0x00}    // √ø 0xff 255
};

#define DEBUG

#define ST7565P_PAGE_SIZE 8
#define ST7565P_COL_SIZE 132
#define ST7565P_PAGE_FONT_SIZE 22

#define ST7565P_SPI_MODE
#ifdef ST7565P_SPI_MODE
#define PIN_CS1_GPIO CONFIG_CHEETAH_ST7565P_LCD_GPIO_CS1
#define PIN_A0_GPIO CONFIG_CHEETAH_ST7565P_LCD_GPIO_A0
#define PIN_SDI_GPIO CONFIG_CHEETAH_ST7565P_LCD_GPIO_SDI
#define PIN_SCL_GPIO CONFIG_CHEETAH_ST7565P_LCD_GPIO_SCL
#endif

//========================================================================  
// st7565p lcd sw struct 
//========================================================================

//
//    LCD design in reverse mode
//
//                                   
//  P = page, C = column, W = word, B = Byte = 8bits 
//
//      C0 C1 .... C131                       C0
//      ______________                        ____
//  P0 | B  B ..... B |                      |b0
//  P1 | B  B ..... B |                      |b1
//  P2 |                        =>           |b2
//  :  |                                  P0 | :
//  :  |                                     | |
//  P7 | B  B ...                            |b7
//
//
//  6B = a Word
//
//      W0 W1 .... W21                      
//      ______________ 
//  P0 | W  W ..... W |  


struct st7565p_lcd_dev
{
	struct miscdevice misc_dev;
	struct delayed_work work;
	struct semaphore sem;
	unsigned char data[ST7565P_PAGE_SIZE][ST7565P_PAGE_FONT_SIZE];
	unsigned char col_data[ST7565P_PAGE_SIZE][ST7565P_COL_SIZE];
	unsigned int cur_page;
	unsigned int cur_word;
	unsigned int cur_col;
};

struct st7565p_lcd_dev *lcd_dev;

void st7565p_lcd_sw_reset(struct st7565p_lcd_dev *dev)
{
	int i, j;
	dev->cur_page = 0;
	dev->cur_word = 0;
	dev->cur_col = 0;

	for (i=0; i<ST7565P_PAGE_SIZE; i++)
	{
		for (j=0; j<ST7565P_PAGE_FONT_SIZE; j++)
			dev->data[i][j] = 0x00;
		for (j=0; j<ST7565P_COL_SIZE; j++)
			dev->col_data[i][j] = 0x00;
	}
}

//========================================================================  
// st7565p lcd hw control flows
//========================================================================

static void
st7565p_lcd_ctrl_command(unsigned char c)
{
#ifdef ST7565P_SPI_MODE
	int i = 0;
	gpio_set_value(PIN_CS1_GPIO, 0);
	gpio_set_value(PIN_SCL_GPIO, 1);
	gpio_set_value(PIN_A0_GPIO, 0);

	//udelay(200);
	for (i=0; i<8; i++)
	{
		gpio_set_value(PIN_SCL_GPIO, 0);
		//udelay(200);
		if (c & (0x1 << (7-i)))
			gpio_set_value(PIN_SDI_GPIO, 1);
		else
			gpio_set_value(PIN_SDI_GPIO, 0);
		//udelay(200);
		gpio_set_value(PIN_SCL_GPIO, 1);
		//udelay(200);
	}
	gpio_set_value(PIN_CS1_GPIO, 1);
#else
	(*(volatile unsigned char*)(0xbc000000)) = c;
#endif

#ifdef DEBUG
	//printk(KERN_DEBUG "LCD: CTRL byte: %02x\n",c);
#endif

}

static void
st7565p_lcd_ctrl_write(unsigned char c)
{
#ifdef ST7565P_SPI_MODE
	int i = 0;
	gpio_set_value(PIN_CS1_GPIO, 0);
	gpio_set_value(PIN_SCL_GPIO, 1);
	gpio_set_value(PIN_A0_GPIO, 1);
	for (i=0; i<8; i++)
	{
		gpio_set_value(PIN_SCL_GPIO, 0);
		if (c & (0x1 << (7-i)))
			gpio_set_value(PIN_SDI_GPIO, 1);
		else
			gpio_set_value(PIN_SDI_GPIO, 0);
		gpio_set_value(PIN_SCL_GPIO, 1);
	}
	gpio_set_value(PIN_CS1_GPIO, 1);
#else
	(*(volatile unsigned char*)(0xbc000001)) = c;
#endif
}

//
// set display RAM start page and column
//
static void
st7565p_lcd_ctrl_address_set(unsigned int page, unsigned int col)
{
	st7565p_lcd_ctrl_command(CMD_RMW);
	st7565p_lcd_ctrl_command(CMD_SET_PAGE | page);
	st7565p_lcd_ctrl_command(CMD_SET_COLUMN_LOWER | (col & 0xf));
	st7565p_lcd_ctrl_command(CMD_SET_COLUMN_UPPER | ((col >> 4) & 0xf));
}

static unsigned int
st7565p_lcd_ctrl_write_word(char word)
{
	int i;
	
	for (i = 0; i < FONT_COL_SIZE; i++)
		st7565p_lcd_ctrl_write(Font8x5[(int)word][i]);
		
	return FONT_COL_SIZE;
}

static void
st7565p_lcd_ctrl_clear_screen(void)
{
	int i, j;
	
	for (i=0; i<ST7565P_PAGE_SIZE; i++)
	{
		st7565p_lcd_ctrl_address_set(i, 0);
		for (j=0; j<ST7565P_COL_SIZE; j++)
			st7565p_lcd_ctrl_write (0x00);
	}
}

//
// lcd hw initial
//
static void
st7565p_lcd_ctrl_init(void)
{
	// set control pins timing
#ifndef ST7565P_SPI_MODE
	*(volatile unsigned int*)(MI_BASE | MR2C) = 0xe058161a;
#endif
	// LCD bias select
	st7565p_lcd_ctrl_command(CMD_SET_BIAS_7);
	// ADC select
	st7565p_lcd_ctrl_command(CMD_SET_ADC_NORMAL);
	// SHL select
	st7565p_lcd_ctrl_command(CMD_SET_COM_NORMAL);
	// Initial display line
	st7565p_lcd_ctrl_command(CMD_SET_DISP_START_LINE);

	// turn on voltage converter (VC=1, VR=0, VF=0)
	st7565p_lcd_ctrl_command(CMD_SET_POWER_CONTROL | 0x4);
	// wait for 50% rising
	mdelay(5);

	// turn on voltage regulator (VC=1, VR=1, VF=0)
	st7565p_lcd_ctrl_command(CMD_SET_POWER_CONTROL | 0x6);
	// wait >=50ms
	mdelay(5);
	// turn on voltage follower (VC=1, VR=1, VF=1)
	st7565p_lcd_ctrl_command(CMD_SET_POWER_CONTROL | 0x7);
	// wait
	mdelay(10);

	// set lcd operating voltage (regulator resistor, ref voltage resistor)
	//st7565p_lcd_ctrl_command(CMD_SET_RESISTOR_RATIO | 0x6);
	st7565p_lcd_ctrl_command(CMD_SET_RESISTOR_RATIO | 0x5);

	// clear screen, before turn of display
	// avoid garbage on screen
	st7565p_lcd_ctrl_clear_screen();

	st7565p_lcd_ctrl_command(CMD_DISPLAY_ON);
	st7565p_lcd_ctrl_command(CMD_SET_ALLPTS_NORMAL);
	mdelay(30);

	st7565p_lcd_ctrl_command(CMD_SET_VOLUME_FIRST);
	st7565p_lcd_ctrl_command(CMD_SET_VOLUME_SECOND | (0x03 & 0x3f));	

	// reverse
	st7565p_lcd_ctrl_command(CMD_SET_COM_REVERSE);

}




//========================================================================  
// st7565p lcd misc dev driver
//========================================================================

#define ST7565P_LCD_MINOR 11

static ssize_t
st7565p_lcd_misc_write( struct file * file, const char __user * buf, 
				size_t count, loff_t *ppos )
{
	struct st7565p_lcd_dev *dev = file->private_data;
	const char __user *p = buf;
	int i;

#ifdef DEBUG
	printk(KERN_DEBUG "LCD: write\n");
#endif

	if (!access_ok(VERIFY_READ, buf, count))
		return -EFAULT;

	st7565p_lcd_ctrl_address_set(dev->cur_page, dev->cur_col);
	
	for ( i = *ppos; count > 0; ++i, ++p, --count ) 
	{
		char c;
		__get_user(c, p);

		if (dev->cur_col >= ST7565P_COL_SIZE)
		{
			dev->cur_page++;
			dev->cur_page = lcd_dev->cur_page & 0x7;
			dev->cur_word = 0;
			dev->cur_col = 0; 
		
			st7565p_lcd_ctrl_address_set(dev->cur_page, dev->cur_col);
		}
		lcd_dev->data[dev->cur_page][dev->cur_word] = c;
#ifdef DEBUG
		printk(KERN_DEBUG "LCD: page %d, word %d, ppos %d, %c\n",
				dev->cur_page, 
				dev->cur_word,
				i,
				c);
#endif
		dev->cur_word++;

		dev->cur_col += st7565p_lcd_ctrl_write_word(c);
	}
	*ppos = i;
	return p - buf;
}


static ssize_t
st7565p_lcd_misc_read( struct file * file, char __user * buf,  
				size_t count, loff_t *ppos )
{
	struct st7565p_lcd_dev *dev = file->private_data;
	char __user *p = buf;
	int page, word;
	int i;
	for (i = *ppos; count > 0; ++i, ++p, --count)
	{
		char c;
		page = (i / ST7565P_PAGE_FONT_SIZE) % ST7565P_PAGE_SIZE;
		word = i % ST7565P_PAGE_FONT_SIZE;		

		c = dev->data[page][word];
			
		__put_user(c, p);
		
#ifdef DEBUG
		printk(KERN_DEBUG "LCD: page %d, word %d, ppos %d, %c\n",
				page, 
				word,
				i,
				c);
#endif
		if (page == dev->cur_page && word == dev->cur_word)
			break;
	}
	*ppos = i;
	return p - buf;
} 

enum {
	ST7565P_LCD_INIT,
	ST7565P_LCD_CLEAR,		
	ST7565P_LCD_WRITE_PAGE,
	ST7565P_LCD_WRITE_PAGE_COL,
	ST7565P_LCD_LSHIFT_COL_OF_PAGE,
};

struct lcd_args {
	char string[64];
	unsigned char byte[ST7565P_COL_SIZE];
	int page;
	int s_col;
	int e_col;
};

static void st7565p_lcd_show_logo(struct st7565p_lcd_dev *dev);

static int
st7565p_lcd_misc_ioctl( struct inode * inode, struct file * file,
				unsigned int cmd, unsigned long arg )
{
	struct st7565p_lcd_dev *dev = file->private_data;
	struct lcd_args args;
	int i, j;
	int word;
	unsigned char s_col_data;

#ifdef DEBUG
	//printk(KERN_DEBUG "LCD: ioctl(%d,%ld)\n",cmd,arg);
#endif
	if (down_interruptible(&dev->sem))
			return -ERESTARTSYS;
		
	switch ( cmd )
	{
	case ST7565P_LCD_INIT:
		st7565p_lcd_ctrl_init();
		st7565p_lcd_sw_reset(lcd_dev);
		st7565p_lcd_show_logo(lcd_dev);
		break;

	case ST7565P_LCD_CLEAR:
		st7565p_lcd_ctrl_clear_screen();
		st7565p_lcd_sw_reset(dev);
		break;

	case ST7565P_LCD_WRITE_PAGE:
		copy_from_user(&args, (struct lcd_args *)arg, sizeof(struct lcd_args));
		
		st7565p_lcd_ctrl_address_set(args.page, 0);
		for (i=0, word=0; i<strlen(args.string); i++, word++)
		{
			st7565p_lcd_ctrl_write_word((args.string)[i]);
			dev->data[args.page][i] = (args.string)[i];
				
			for (j=0; j<FONT_COL_SIZE; j++)
				dev->col_data[args.page][word*FONT_COL_SIZE+j] = Font8x5[(int)(args.string)[i]][j];
		}
		break;

	case ST7565P_LCD_WRITE_PAGE_COL:
		copy_from_user(&args, (struct lcd_args *)arg, sizeof(struct lcd_args));
		
		st7565p_lcd_ctrl_address_set(args.page, 0);
		for (i=0; i<ST7565P_COL_SIZE; i++)
		{
			st7565p_lcd_ctrl_write((args.byte)[i]);
			dev->col_data[args.page][i] = args.byte[i];
		}
		break;

	case ST7565P_LCD_LSHIFT_COL_OF_PAGE:
		copy_from_user(&args, (struct lcd_args *)arg, sizeof(struct lcd_args));
		
		s_col_data = dev->col_data[args.page][args.s_col];
		st7565p_lcd_ctrl_address_set(args.page, args.s_col); 

		for (i = args.s_col; i <= args.e_col; i++)
		{
	
			if (i == args.e_col)
			{
				dev->col_data[args.page][i] = s_col_data;
				st7565p_lcd_ctrl_write(s_col_data);
			}
			else	
			{
				dev->col_data[args.page][i] = dev->col_data[args.page][i+1];
				st7565p_lcd_ctrl_write(dev->col_data[args.page][i+1]);
			}
		}
		break;

	default:
		return -EINVAL;
	}

	up(&dev->sem);
	return 0;
}

static int
st7565p_lcd_misc_open( struct inode * inode, struct file * file )
{
	if (lcd_dev) 
        	file->private_data = lcd_dev;
	else
		return -ENOMEM;
        return 0;         
}

const struct file_operations st7565p_lcd_misc_fops = {
	.write	= st7565p_lcd_misc_write,
	.read   = st7565p_lcd_misc_read,
	.ioctl	= st7565p_lcd_misc_ioctl,
	.open	= st7565p_lcd_misc_open,
};


//========================================================================  
// st7565p lcd dev driver
//========================================================================
/*
static struct platform_driver st7565p_lcd_driver = {
	.probe          = st7565p_lcd_probe,
	.remove         = __devexit_p(st7565p_lcd_remove),
	.suspend        = NULL,
	.resume         = NULL,
	.driver         = {
		.name   = "st7565p_lcd",
		.owner  = THIS_MODULE,
	},
};

static int __devinit st7565p_lcd_probe(struct platform_device *pdev)
{
	if (lcd_dev)
	{
		INIT_DELAYED_WORK(&lcd_dev->work, st7565p_lcd_scan);
	
		device_init_wakeup(&pdev->dev, pdata->wakeup);
	}       
	return 0;
}

static int __devexit cta_ana_keypad_remove(struct platform_device *pdev)   
{
	struct ana_keypad *keypad = platform_get_drvdata(pdev);
	
	device_init_wakeup(&pdev->dev, 0);
	platform_set_drvdata(pdev, NULL);
	kfree(keycodes);
	kfree(keypad);
	
	return 0;
}
*/
//========================================================================  
// st7565p lcd dev driver
//========================================================================

#if defined(CONFIG_CHEETAH_LCD_LOGO)
static char *lcd_strsep(char **txt, char *delim, int *br)
{
	static int force_br = 0;
	char *head, *ptr;

	if (!txt || !delim || !br)
		return NULL;
	*br = 0;
	head = *txt;
	if ((!head) || (strlen(head) == 0))
		return NULL;
	if (force_br) {
		*br = 1;
		force_br = 0;
		return head;
	}
	while (*head) {
		if ((*head == '\\') && (*(head+1) == 'n')) {
			*br = 1;
			*head = 0;
			*txt = head + 2;
			return head;
		}
		else if (*head == ' ')
			head++;
		else
			break;
	}
	if ((!head) || (strlen(head) == 0))
		return NULL;
	for (ptr=head; *ptr; ptr++) {
		if ((*ptr == '\\') && (*(ptr+1) == 'n')) {
			*ptr = 0;
			ptr += 2;
			force_br = 1;
			break;
		}
		else if (*ptr == ' ') {
			*ptr = 0;
			ptr += 1;
			break;
		}
	}
	if (*ptr == 0)
		*txt = 0;
	else
		*txt = ptr;

	return head;
}

static int lcd_align_center(char *canvas, int width)
{
	char *ptr = canvas + width - 1;
	int len, shift;
	int i;

	while (ptr >= canvas) {
		if (*ptr != ' ')
			break;
		ptr--;
	}
	len = ptr - canvas + 1;
	shift = (width - len) / 2;

	if ((len > 0) && (shift > 0)) {
		for (i=len-1; i>=0; i--) {
			canvas[i+shift] = canvas[i];
			canvas[i] = ' ';
		}
	}
	
	return 0;
}

static int st7565p_lcd_update_logo(struct st7565p_lcd_dev *lcddev, 
                                    char *window, int width, int height, int pitch, 
                                    char *txt, int len)
{
	struct device *dev = lcddev->misc_dev.this_device;
	char *logo, *canvas;
	char *ptr;
	int i, j, k;
	int br = 0, err = 0;

//	dev_info(dev, "w=%d;h=%d;p=%d\n", width, height, pitch);
//	dev_info(dev, "txt=%s;l=%d\n", txt, len);

	if (len >= height * width) {
		for (i=0;i<height * width;i++) {
			if ((txt[i] == '\\') && (txt[i+1] == 'n'))
				txt[i] = txt[i+1] = ' ';
		}
		logo = window;
		for (i=0; i<height; i++, logo+=pitch) {
			memcpy(logo, txt + i * width, width);
		}
	}
	else {
		canvas = kzalloc((height + 1) * pitch, GFP_KERNEL);

		if (unlikely(!canvas)) {
			dev_err(dev, "Could not allocate canvas\n");
			return -ENOMEM;
		}

		i = j = k = 0;
		memset(canvas, ' ', (height + 1) * pitch);
		while ((ptr = lcd_strsep(&txt, " ", &br)) != NULL) {
//			dev_info(dev, "[%s][%d][%s] br[%d]\n", ptr, (txt - ptr) - 1, txt, br);
			j = strlen(ptr);
			if ((i > 0) && (((i + j) >= width) || br)) {
				/* move to center */
				lcd_align_center(canvas, width);
				/* copy to canvas */
				memcpy(canvas + (1 + k) * pitch, canvas, width);
				/* clear */
				memset(canvas, ' ', width);
				i = 0;
				k++;
				if (br)
					continue;
			}
			if ((i + j) < width) {
				for (; j>0; i++, j--, ptr++) {
					canvas[i] = *ptr;
				}
				if (i < width)
					canvas[i++] = ' ';
			}
			else {
				/* text too long, drop it */
				dev_err(dev, "text[%s] too long, drop it\n", ptr);
			}
		}
		if (i > 0) {
			/* move to center */
			lcd_align_center(canvas, width);
			/* copy to canvas */
			memcpy(canvas + (1 + k) * pitch, canvas, width);
			k++;
		}

		/* copy to window from canvas */
		logo = window + ((height - k) / 2) * pitch;
		for (i=0; i<k; i++, logo+=pitch) {
			memcpy(logo, canvas + (1 + i) * pitch, width);
		}

		kfree(canvas);
	}

	return err;
}
#endif

static void st7565p_lcd_show_logo(struct st7565p_lcd_dev *dev)
{
	unsigned int i, j;
	unsigned int page = 0, word = 0;

#if defined(CONFIG_CHEETAH_LCD_LOGO)
	char logo[ST7565P_PAGE_FONT_SIZE * 8 + 1] =	
				"                      "  
				" ******************** "  
				" *                  * "  
				" *                  * " 
				" *                  * " 
				" *                  * "  
				" ******************** "  
				"                      ";

	char canvas[ST7565P_PAGE_FONT_SIZE * 8 + 1] = CONFIG_CHEETAH_LCD_LOGO;
	st7565p_lcd_update_logo(dev, 
							(logo + ST7565P_PAGE_FONT_SIZE * 2 + 2), (ST7565P_PAGE_FONT_SIZE - 4), 4, ST7565P_PAGE_FONT_SIZE, 
							canvas, (sizeof(CONFIG_CHEETAH_LCD_LOGO) - 1));
#else
	const char logo[] =	
				"                      "
				" ******************** "  
				" *                  * "  
				" *    Welcome to    * " 
				" *     Cheetah      * "
				" *                  * "  
				" ******************** "
				"                      ";
#endif

	for (i=0; i<strlen(logo); i++, word++)
	{
		if (i % ST7565P_PAGE_FONT_SIZE == 0)
		{
			if (i != 0)
			{
				page++;
				page = page & 0x7;
				word = 0;
			}
		
			st7565p_lcd_ctrl_address_set(page, 0);
		}
		st7565p_lcd_ctrl_write_word(logo[i]);
		
		dev->data[page][i%ST7565P_PAGE_FONT_SIZE] = logo[i];
	
		for (j=0; j<FONT_COL_SIZE; j++)
			dev->col_data[page][word*FONT_COL_SIZE+j] = Font8x5[(int)logo[i]][j];
	}
}

static void st7565p_lcd_show_logo_work(struct work_struct *work)
{
	struct st7565p_lcd_dev *dev = container_of(work, struct st7565p_lcd_dev, work.work);

#if defined(CONFIG_CHEETAH_LCD_BACKLIGHT_PWM_A) || defined(CONFIG_CHEETAH_LCD_BACKLIGHT_PWM_B)
	if (pwm) {
#if defined(CONFIG_CHEETAH_LCD_BACKLIGHT_PWM_A)
		int idx = PWM_A;
#elif defined(CONFIG_CHEETAH_LCD_BACKLIGHT_PWM_B)
		int idx = PWM_B;
#else
#error "Not define PWM for LCD BackLight!"
#endif
		pwm->polarity[idx] = 1;
//		pwm->sweep[idx];
		pwm->duty[idx] = 30;
		pwm->mode[idx] = 0;
		pwm->enable[idx] = 1;
		pwm_update();
	}
#endif
	st7565p_lcd_show_logo(dev);
}

/*
static void st7565p_lcd_scrolling_text(
	struct st7565p_lcd_dev *dev,
	unsigned int page, unsigned int s_col, unsigned int e_col)
{
	int i;
	unsigned char s_col_data = dev->col_data[page][s_col];

	if (down_interruptible(&dev->sem))
		return;

	st7565p_lcd_ctrl_address_set(page, s_col); 

	for (i = s_col; i <= e_col; i++)
	{
	
		if (i == e_col)
		{
			dev->col_data[page][i] = s_col_data;
			st7565p_lcd_ctrl_write(s_col_data);
		}
		else	
		{
			dev->col_data[page][i] = dev->col_data[page][i+1];
			st7565p_lcd_ctrl_write(dev->col_data[page][i+1]);
		}
	#ifdef DEBUG
		printk(KERN_DEBUG "LCD: scrolling pos %d data %1x\n", i, dev->col_data[page][i]);
	#endif
	}

	up(&dev->sem);
}

static void st7565p_lcd_scan(struct work_struct *work)
{
	struct st7565p_lcd_dev *dev = container_of(work, struct st7565p_lcd_dev, work.work);
	const int delay = 10;
	
	st7565p_lcd_scrolling_text(dev, 4, 12, 119);
	
	schedule_delayed_work(&dev->work,delay);	
}
*/
static int __init
st7565p_lcd_init(void)
{
	int retval;

	lcd_dev = (struct st7565p_lcd_dev *) kzalloc(sizeof(struct st7565p_lcd_dev), GFP_KERNEL);
	if (!lcd_dev) {
		kfree(lcd_dev);
		return -ENOMEM;
	}
	
	(lcd_dev->misc_dev).minor  = ST7565P_LCD_MINOR;
	(lcd_dev->misc_dev).name   = "cta_lcd";
	(lcd_dev->misc_dev).fops   = &st7565p_lcd_misc_fops;

	retval = misc_register(&(lcd_dev->misc_dev));
	if(retval < 0){
		printk(KERN_INFO "LCD: misc_register failed\n");
		return retval;
	}

	init_MUTEX(&lcd_dev->sem);

#ifdef ST7565P_SPI_MODE
	gpio_request(PIN_CS1_GPIO, "cta_lcd");
	gpio_request(PIN_A0_GPIO, "cta_lcd");
	gpio_request(PIN_SDI_GPIO, "cta_lcd");
	gpio_request(PIN_SCL_GPIO, "cta_lcd");
	gpio_direction_output(PIN_CS1_GPIO, 1);
	gpio_direction_output(PIN_A0_GPIO, 0);
	gpio_direction_output(PIN_SDI_GPIO, 0);
	gpio_direction_output(PIN_SCL_GPIO, 1);
#endif

	st7565p_lcd_ctrl_init();
	
	st7565p_lcd_sw_reset(lcd_dev);

	INIT_DELAYED_WORK(&lcd_dev->work, st7565p_lcd_show_logo_work);
	schedule_delayed_work(&lcd_dev->work, 2 * HZ);

	//INIT_DELAYED_WORK(&lcd_dev->work, st7565p_lcd_scan);
	//schedule_delayed_work(&lcd_dev->work, 0);
	
	return 0;
}

static void __exit
st7565p_lcd_exit(void)
{
	misc_deregister(&(lcd_dev->misc_dev));
	kfree(lcd_dev);
}


module_init(st7565p_lcd_init);
module_exit(st7565p_lcd_exit);
